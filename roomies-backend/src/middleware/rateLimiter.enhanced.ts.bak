/**
 * Enhanced Rate Limiting Middleware with Redis Backing
 * Addresses: CRITICAL P0 - No Rate Limiting vulnerability
 */

import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import { Redis } from 'ioredis';
import { Request, Response } from 'express';
import { logger } from '@/utils/logger';

// Extend Request type to include userId
declare module 'express-serve-static-core' {
  interface Request {
    userId?: string;
    user?: any;
  }
}

// Initialize Redis client for rate limiting
const redisClient = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  db: parseInt(process.env.REDIS_DB || '0'),
  keyPrefix: process.env.REDIS_KEY_PREFIX || 'roomies:ratelimit:',
  retryStrategy: (times: number) => {
    const delay = Math.min(times * 50, 2000);
    logger.warn(`Redis connection failed, retrying in ${delay}ms...`);
    return delay;
  }
});

// Handle Redis connection events
redisClient.on('connect', () => {
  logger.info('✅ Rate limiter Redis connected');
});

redisClient.on('error', (err) => {
  logger.error('❌ Rate limiter Redis error:', err);
});

/**
 * Create a custom key generator based on user ID or IP
 */
const keyGenerator = (req: Request): string => {
  // Use user ID if authenticated, otherwise use IP
  if (req.userId) {
    return `user:${req.userId}`;
  }
  return `ip:${req.ip || req.socket.remoteAddress || 'unknown'}`;
};

/**
 * Custom handler for rate limit exceeded
 */
const rateLimitHandler = (req: Request, res: Response) => {
  logger.warn('Rate limit exceeded', {
    userId: req.userId,
    ip: req.ip,
    path: req.path,
    method: req.method
  });

  res.status(429).json({
    success: false,
    error: {
      message: 'Too many requests. Please try again later.',
      code: 'RATE_LIMIT_EXCEEDED',
      retryAfter: res.getHeader('Retry-After')
    }
  });
};

/**
 * Standard rate limiter for general API endpoints
 * 100 requests per 15 minutes
 */
export const standardRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'standard:',
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Max requests per window
  message: 'Too many requests from this IP/user, please try again later.',
  standardHeaders: true, // Return rate limit info in headers
  legacyHeaders: false,
  keyGenerator,
  handler: rateLimitHandler,
  skip: (req: Request) => {
    // Skip rate limiting for health checks
    return req.path === '/health' || req.path === '/api/health';
  }
});

/**
 * Strict rate limiter for authentication endpoints
 * 5 attempts per 15 minutes
 */
export const authRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'auth:',
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Max 5 login attempts
  message: 'Too many authentication attempts, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req: Request) => {
    // For auth, use email if provided, otherwise IP
    const email = req.body?.email;
    if (email) {
      return `email:${email}`;
    }
    return `ip:${req.ip || req.socket.remoteAddress || 'unknown'}`;
  },
  handler: rateLimitHandler,
  skipSuccessfulRequests: true // Don't count successful logins
});

/**
 * Password reset rate limiter
 * 3 attempts per hour per email
 */
export const passwordResetRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'reset:',
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // Max 3 reset attempts per hour
  message: 'Too many password reset attempts, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req: Request) => {
    const email = req.body?.email || req.params?.email;
    return `reset:${email || req.ip}`;
  },
  handler: rateLimitHandler
});

/**
 * API key rate limiter for external API access
 * 1000 requests per hour
 */
export const apiKeyRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'apikey:',
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 1000, // 1000 requests per hour for API keys
  message: 'API rate limit exceeded.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req: Request) => {
    const apiKey = req.headers['x-api-key'] as string;
    return `apikey:${apiKey || 'unknown'}`;
  },
  handler: rateLimitHandler
});

/**
 * Create operation rate limiter
 * Prevents spam creation of resources
 */
export const createOperationRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'create:',
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 50, // Max 50 creates per hour
  message: 'Too many creation requests, please slow down.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator,
  handler: rateLimitHandler
});

/**
 * File upload rate limiter
 * 10 uploads per hour
 */
export const uploadRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'upload:',
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // Max 10 uploads per hour
  message: 'Upload limit exceeded, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator,
  handler: rateLimitHandler
});

/**
 * WebSocket connection rate limiter
 * 10 connections per minute
 */
export const wsConnectionRateLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redisClient.call(...args),
    prefix: 'ws:',
  }),
  windowMs: 60 * 1000, // 1 minute
  max: 10, // Max 10 WebSocket connections per minute
  message: 'Too many WebSocket connection attempts.',
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator,
  handler: rateLimitHandler
});

/**
 * Dynamic rate limiter that adjusts based on server load
 */
export class DynamicRateLimiter {
  private static instance: DynamicRateLimiter;
  private currentLoad: number = 0;

  private constructor() {
    // Monitor server load every 30 seconds
    setInterval(() => this.updateServerLoad(), 30000);
  }

  static getInstance(): DynamicRateLimiter {
    if (!DynamicRateLimiter.instance) {
      DynamicRateLimiter.instance = new DynamicRateLimiter();
    }
    return DynamicRateLimiter.instance;
  }

  private updateServerLoad() {
    // This could check CPU, memory, response times, etc.
    const memUsage = process.memoryUsage();
    const heapUsed = memUsage.heapUsed / memUsage.heapTotal;
    this.currentLoad = heapUsed;
  }

  getAdjustedLimit(baseLimit: number): number {
    // Reduce limits when server is under load
    if (this.currentLoad > 0.8) {
      return Math.floor(baseLimit * 0.5); // 50% reduction
    } else if (this.currentLoad > 0.6) {
      return Math.floor(baseLimit * 0.75); // 25% reduction
    }
    return baseLimit;
  }
}

/**
 * Cleanup function for graceful shutdown
 */
export const cleanupRateLimiter = async (): Promise<void> => {
  try {
    await redisClient.quit();
    logger.info('Rate limiter Redis connection closed');
  } catch (error) {
    logger.error('Error closing rate limiter Redis connection:', error);
  }
};

// Export all rate limiters
export default {
  standard: standardRateLimiter,
  auth: authRateLimiter,
  passwordReset: passwordResetRateLimiter,
  apiKey: apiKeyRateLimiter,
  createOperation: createOperationRateLimiter,
  upload: uploadRateLimiter,
  wsConnection: wsConnectionRateLimiter,
  cleanup: cleanupRateLimiter
};
